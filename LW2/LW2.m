%%
% Лабораторная работа 2 
% Работа с графикой
% Вариант 2
%%
% Двумерная графика, часть первая
%%
% Task 1
% Написать функцию compareInterp(x, xx, f), которая принимает на вход 
% две сетки, xx (более мелкую) и x (более крупную), x ⊂ xx, 
% и указатель на функцию f (function handle). 
% Эта функция рисует графики f на сетке xx и графики функций, 
% получающихся интерполированием f с сетки x на сетку xx различными 
% методами (флаги команды interp1: nearest, linear, spline, cubic). 
% График оборудовать легендой, а также заголовком с наименованием 
% метода интерполяции.

x = linspace(-10, 10, 50);
xx = linspace(-10, 10, 500);
f = @(x) x .^ 2;

compareInterpr(x, xx, f);

%%
%%
% Task 2
% Подобрать набор функций, на котором продемонстрировать преимущества 
% и недостатки каждого метода интерполирования 
% (хотя бы 4 нетривиальных примера).
%%  
%{ 
Nearest
Алгоритм ближайшего соседа выбирает значение ближайшей точки 
и вообще не учитывает значения соседних точек, 
получая кусочно-постоянную интерполяцию.

Достоинства: 

1) удобен для ступенчатых функций или функций, заданных дискретно;
2) сложность восстановления O(n), где n - число интерполируемых точек 
3) простота реализации

Недостатки: 

1) Низкая точкность для малого количества интерполяционных точек
2) Разрывная и недифференцируемая функция (нельзя реализовать непрерывные
функции)

Удачный пример:
 
1) любая ступенчатая или дискретная функция 
(например, дискретная фукнция распределения) 

Плохой пример: 

1) Любая непрерывная или интегрируемая функция 
2) Любая функция с точками разрыва второго рода (sin(1/x))
%}

x = linspace(0, 2 * pi, 10);
xx = linspace(0, 2 * pi, 1000);
f = @(x) cos(x);
compareInterpr(x, xx, f);
%%
%{ 
Linear 

Достоинства: 

1) cложность восстановления O(n * log(n)), где n - число интерполируемых точек 
2) высокая точность при большом числе интерполяционных точек
3) хороша для непрерывных функций 

Недостатки: 

1) недифференцируемая в точках интерполяции
2) Не подходит для функций с счетным числом точек разрыва первого и второго рода 
(разрыв будет неаккуратно "склеен") 

Удачный пример: 

1) Любая дифференциируемая функция (например, многочлен) 

Плохой пример: 

1) Любая кусочно-непрерывная фукнция 
2) Любая функция со счетным числом точек разрыва первого рода, например abs(x) / x 
3) Любая функция со счетным числом точек разрыва второго рода, например 1 / x 
%}

x = linspace(-10,10, 10);
xx = linspace(-10, 10, 100);
f = @(x) abs(x + 5) ./ (x + 5) + abs(x) ./ x + abs(x - 5) ./ (x - 5);
compareInterpr(x, xx, f);
%%
%{ 
Spline

Достоинства: 

1) Скорость восстановления O((n-1)n), где n - число интерполяционных точек
2) непрерывная и дифференциируемая функция

Недостатки: 

1) не эффективен для построения функций с точками разрыва первого и второго рода 

Удачный пример: 

1) любая дифференциируемая или интрегируемая функция 

Плохой пример:

1) любая функция с точкой разрыва первого и второго рода 
%}

x = linspace(-50, 50, 50);
xx = linspace(-50, 50, 100);
f = @(x) (abs(x) ./ x + 1 ./ (x - 5));
compareInterpr(x, xx, f);
%%
%{ 
Cubic сплайн Эрмита

Достоинства: 

1) скорость восстановления O(mn), где m - число интерполируемых точек, 
2) Непрерывный и дифференциируеммый

Недостатки: 

1) не эффективен для построения функций с точками разрыва первого и второго рода 

Хороший пример: 

1) любая дифференциируемая и интрегируемая функция 

Прохой пример: 

1) любая функция с точкой разрыва первого и второго рода 

%}

x = linspace(-50, 50, 100);
xx = linspace(-50, 50, 1000);
f4 = @(x) 2 .^ (1 ./ x) + abs(x - 10) / (x - 10);
compareInterpr(x, xx, f);

%{
Для всех этих методов есть общий недостаток: 
точки разрыва первого и второго рода.
%}

%%
% Task 3
% Оценить априорную погрешность интерполирования линейным методом. Для  
% построения оценки считать известными максимумы производных. Построить
% график априорной и получившейся погрешности для двух функций: на одной 
% с большим отклонением от априорной погрешности, на другой - с малым.

f = @(x) sin(10 * x);
g = @(x) sin(x);

f_2 = @(x) -100 * sin(x);
g_2 = @(x) -sin(x);

xx = linspace(0, 2 * pi, 100);
x = linspace(0, 2 * pi, 50);

yf = f(xx);
yg = g(xx);
yf_2 = f_2(xx);
yg_2 = g_2(xx);
Mf = max(abs(yf_2));
Mg = max(abs(yg_2));

x0 = x(1);
x1 = x(2);
lin_pol = @(x) abs((x - x0) .* (x - x1));
min_lin_pol = lin_pol(0.5 * (x0 + x1));

f_arr = ones(size(xx, 2));
g_arr = ones(size(xx, 2));
f_apr_error = f_arr * (0.5 * Mf * min_lin_pol);
g_apr_error = g_arr * (0.5 * Mg * min_lin_pol);

f_apost_error = abs(yf - interp1(x, f(x), xx, 'linear'));
g_apost_error = abs(yg - interp1(x, g(x), xx, 'linear'));

fig = figure('Position', [100 100 1000 1000]);
    
subplot(2, 1, 1);
plot(xx, f_apr_error, 'r', xx, f_apost_error, 'b');
title('sin(10 * x)');
legend({'apriori', 'aposteriori'});

subplot(2, 1, 2);
plot(xx, g_apr_error, 'r', xx, g_apost_error, 'b');
title('sin(x)');
legend({'apriori', 'aposteriori'});
%
%%
function compareInterpr(x, xx, f)
    fig = figure('Position', [100 100 1000 1000]);
    
    subplot(5, 1, 1);
    plot(xx, f(xx));
    title('No interpolation');
    legend({'no interpolation'});
    xlabel('x');
    ylabel('f(x)');
    
    subplot(5, 1, 2);
    nearestVal = interp1(x, f(x), xx, 'nearest');
    plot(xx, nearestVal);
    title('Nearest');
    legend({'Nearest'});
    xlabel('x');
    ylabel('f(x)');
    
    subplot(5, 1, 3)
    linearVal = interp1(x, f(x), xx, 'linear');
    plot(xx, linearVal);
    title('Linear');
    legend({'Linear'});
    xlabel('x');
    ylabel('f(x)');
    
    subplot(5, 1, 4)
    splineVal = interp1(x, f(x), xx, 'spline');
    plot(xx, splineVal);
    title('Spline');
    legend({'Spline'});
    xlabel('x');
    ylabel('f(x)');
    
    subplot(5, 1, 5)
    cubicVal = interp1(x, f(x), xx, 'pchip');
    plot(xx, cubicVal);
    title('Cubic');
    legend({'Cubic'});
    xlabel('x');
    ylabel('f(x)');
end